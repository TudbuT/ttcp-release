package de.tudbut.mod.client.ttcp.mods.exploit;

import de.tudbut.type.Vector3d;
import net.minecraft.block.Block;
import net.minecraft.block.BlockFalling;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntityChest;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.*;
import net.minecraft.world.storage.WorldInfo;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import org.lwjgl.opengl.GL11;
import de.tudbut.mod.client.ttcp.TTCp;
import de.tudbut.mod.client.ttcp.gui.lib.component.Button;
import de.tudbut.mod.client.ttcp.utils.ChatUtils;
import de.tudbut.mod.client.ttcp.utils.Module;
import de.tudbut.mod.client.ttcp.utils.ThreadManager;
import de.tudbut.mod.client.ttcp.utils.WorldGeneratorV2;
import de.tudbut.mod.client.ttcp.utils.category.Exploit;
import de.tudbut.obj.Save;
import de.tudbut.tools.Lock;

import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.Map;

import static de.tudbut.mod.client.ttcp.utils.Tesselator.*;

@Exploit
public class SeedOverlay extends Module {
    Map<BlockPos, Integer> toRender = new HashMap<>();
    Map<BlockPos, Boolean> toRenderTiles = new HashMap<>();
    WorldGeneratorV2 generator;
    World world;
    String worldOptions;
    WorldType worldType;
    
    @Save
    long seed = Long.MAX_VALUE;
    
    boolean isUpdating = false;
    Lock lock = new Lock();
    int renderType = 0;
    boolean mode = false;
    
    static final ArrayList<Block> disableCheck = new ArrayList<>();
    
    static {
        disableCheck.add(Blocks.GLOWSTONE);
        disableCheck.add(Blocks.LOG);
        disableCheck.add(Blocks.LEAVES);
        disableCheck.add(Blocks.LOG2);
        disableCheck.add(Blocks.LEAVES2);
        disableCheck.add(Blocks.COAL_ORE);
        disableCheck.add(Blocks.IRON_ORE);
        disableCheck.add(Blocks.GOLD_ORE);
        disableCheck.add(Blocks.LAPIS_ORE);
        disableCheck.add(Blocks.EMERALD_ORE);
        disableCheck.add(Blocks.DIAMOND_ORE);
        disableCheck.add(Blocks.TALLGRASS);
        disableCheck.add(Blocks.DOUBLE_PLANT);
        disableCheck.add(Blocks.VINE);
        disableCheck.add(Blocks.YELLOW_FLOWER);
        disableCheck.add(Blocks.RED_FLOWER);
        disableCheck.add(Blocks.BROWN_MUSHROOM);
        disableCheck.add(Blocks.RED_MUSHROOM);
        disableCheck.add(Blocks.BROWN_MUSHROOM_BLOCK);
        disableCheck.add(Blocks.RED_MUSHROOM_BLOCK);
        disableCheck.add(Blocks.FIRE);
        disableCheck.add(Blocks.DEADBUSH);
    }
    
    { updateBinds(); }
    
    public void updateBinds() {
        subComponents.clear();
        subComponents.add(new Button("Update world data", it -> ThreadManager.run(() -> {
            world = TTCp.world;
            worldOptions = TTCp.world.getWorldInfo().getGeneratorOptions();
            worldType = TTCp.world.getWorldType();
            ChatUtils.print("Downloaded data, now generating chunks!");
            if(seed != Long.MAX_VALUE) {
                ThreadManager.run(() -> {
                    if(generator != null) {
                        try {
                            generator.stopServer();
                        }
                        catch (Exception ignore) { }
                    }
                    generator = createFreshWorldCopy(world, seed);
                    world = generator.getWorld(TTCp.world.provider.getDimension());
                });
            }
            else
                ChatUtils.print("Error: No seed given! ',seedoverlay <seed>' to set");
        })));
        subComponents.add(new Button("Delete world data", it -> ThreadManager.run(() -> {
            world = null;
            generator.stopServer();
            generator = null;
        })));
        subComponents.add(new Button("Render type: " + (renderType == 0 ? "Box" : (renderType == 1 ? "Marker" : "Plane")), it -> {
            renderType++;
            if(renderType > 2)
                renderType = 0;
            it.text = "Render type: " + (renderType == 0 ? "Box" : (renderType == 1 ? "Marker" : "Plane"));
        }));
        subComponents.add(new Button("Type: " + (!mode ? "SeedOverlay" : "GappleFinder"), it -> {
            mode = !mode;
            toRender.clear();
            it.text = "Type: " + (!mode ? "SeedOverlay" : "GappleFinder");
        }));
    }
    
    @Override
    public void onConfigLoad() {
        updateBinds();
    }
    
    private void updateSeedOverlay() {
        Map<BlockPos, Integer> toRender = new HashMap<>();
        EntityPlayer player = TTCp.player;
        
        if(world != null) {
            world = generator.getWorld(TTCp.world.provider.getDimension());
            //ChatUtils.print("Rendering SeedOverlay");
            
            for (int z = -8 * 16; z < 8 * 16; z++) {
                for (int x = -8 * 16; x < 8 * 16; x++) {
                    int theX = (int) (player.posX + x);
                    int theZ = (int) (player.posZ + z);
                    
                    for (int y = 0; y < 256; y++) {
                        BlockPos bp = new BlockPos(theX, y, theZ);
                        if (TTCp.mc.world.isBlockLoaded(bp, false) && world.getChunk(bp).isTerrainPopulated()) {
                            //ChatUtils.print("Check!");
                            IBlockState a = TTCp.world.getBlockState(bp);
                            IBlockState b = world.getBlockState(bp);
                            if(!mode) {
                                if (!a.getMaterial().equals(b.getMaterial())) {
                                    if (
                                            !a.getMaterial().isLiquid() && !b.getMaterial().isLiquid() &&
                                            !(BlockFalling.class.isAssignableFrom(a.getBlock().getClass())) && !(BlockFalling.class.isAssignableFrom(b.getBlock().getClass())) &&
                                            !disableCheck.contains(a.getBlock()) && !disableCheck.contains(b.getBlock())
                                    ) {
                                        if (renderType == 2)
                                            bp = new BlockPos(bp.getX(), 42, bp.getZ());
                                        
                                        if (a.getMaterial() == Material.AIR)
                                            toRender.put(bp, -1);
                                        else if (b.getMaterial() == Material.AIR)
                                            toRender.put(bp, 1);
                                        else
                                            toRender.put(bp, 0);
                                        
                                    }
                                }
                            }
                            else if(b.getBlock() == Blocks.CHEST) {
                                TileEntityChest chest = (TileEntityChest) world.getTileEntity(bp);
                                assert chest != null;
                                //noinspection ConstantConditions
                                if(chest.getLootTable() != null) {
                                    chest.fillWithLoot(null);
                                    boolean gap = false;
                                    boolean egap = false;
                                    for (int i = 0; i < 9 * 3; i++) {
                                        if(chest.getStackInSlot(i).getItem() == Items.GOLDEN_APPLE) {
                                            gap = true;
                                            if(chest.getStackInSlot(i).getMetadata() == 1)
                                                egap = true;
                                        }
                                    }
                                    if(gap) {
                                        toRenderTiles.put(bp, egap);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        lock.lock();
        this.toRender = toRender;
        lock.unlock();
    }
    
    public static WorldGeneratorV2 createFreshWorldCopy(World worldIn, long seed) {
        WorldInfo i = worldIn.getWorldInfo();
        
        NBTTagCompound nbt = i.cloneNBTCompound(null);
        nbt.setLong("RandomSeed", seed);
        WorldSettings settings = new WorldSettings(seed, worldIn.getWorldInfo().getGameType(), true, false, worldIn.getWorldType());
        settings.setGeneratorOptions(worldIn.getWorldInfo().getGeneratorOptions());
        
        WorldGeneratorV2 w = WorldGeneratorV2.create(settings);
        w.startServerThread();
        while (!w.done) {
            ChatUtils.print(w.percentDone + "% Generated");
            try {
                Thread.sleep(1000);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        ChatUtils.print("Done!");
        return w;
    }
    
    @Override
    public void onChat(String s, String[] args) {
        isUpdating = false;
        try {
            seed = Long.parseLong(s);
        }
        catch (NumberFormatException e) {
            seed = s.hashCode();
        }
        ChatUtils.print("Set! " + seed);
    }
    
    Vec3d pos = new Vec3d(0,0,0);
    
    @Override
    public void onTick() {
        if(isUpdating)
            return;
        isUpdating = true;
        ThreadManager.run(() -> {
            try {
                updateSeedOverlay();
            }
            catch (Throwable e) {
                e.printStackTrace();
            }
            isUpdating = false;
        });
    }
    
    @SubscribeEvent
    public void onRenderWorld(Event event) {
        
        if(event instanceof RenderWorldLastEvent)
            if(this.enabled && TTCp.isIngame()) {
                Entity e = TTCp.mc.getRenderViewEntity();
                assert e != null;
                pos = e.getPositionEyes(((RenderWorldLastEvent) event).getPartialTicks()).add(0, -e.getEyeHeight(), 0);
                lock.waitHere(500);
                if(!mode) {
                    Map<BlockPos, Integer> toRender = this.toRender;
                    BlockPos[] toRenderPositions = this.toRender.keySet().toArray(new BlockPos[0]);
                    
                    if (toRenderPositions.length > 50000) {
                        ChatUtils.print("Too many blocks to render!");
                        return;
                    }
                    
                    for (int i = 0; i < toRenderPositions.length; i++) {
                        int color = toRender.get(toRenderPositions[i]);
                        
                        switch (color) {
                            case 1:
                                color = 0x4000ff00;
                                break;
                            case 0:
                                color = 0x40808000;
                                break;
                            case -1:
                                color = 0x40ff0000;
                                break;
                        }
                        
                        if (renderType == 2)
                            color += 0x20000000;
                        
                        drawAroundBlock(
                                new Vector3d(
                                        toRenderPositions[i].getX() + 0.5,
                                        toRenderPositions[i].getY(),
                                        toRenderPositions[i].getZ() + 0.5
                                ),
                                color,
                                0
                        );
                    }
                }
                else {
                    try {
                        Map<BlockPos, Boolean> toRender = this.toRenderTiles;
                        BlockPos[] toRenderPositions = toRender.keySet().toArray(new BlockPos[0]);
    
                        if (toRenderPositions.length > 50000) {
                            ChatUtils.print("Too many blocks to render!");
                            return;
                        }
    
                        for (int i = 0 ; i < toRenderPositions.length ; i++) {
                            if (toRender.get(toRenderPositions[i])) {
                                drawAroundBlock(
                                        new Vector3d(
                                                toRenderPositions[i].getX() + 0.5,
                                                toRenderPositions[i].getY(),
                                                toRenderPositions[i].getZ() + 0.5
                                        ),
                                        0x80ffa000,
                                        255 - toRenderPositions[i].getY()
                                );
                            }
                            else
                                drawAroundBlock(
                                        new Vector3d(
                                                toRenderPositions[i].getX() + 0.5,
                                                toRenderPositions[i].getY(),
                                                toRenderPositions[i].getZ() + 0.5
                                         ),
                                        0xffe0c000,
                                        0
                                );
                        }
                    } catch (ConcurrentModificationException ignore) {
                        // Fuck you.
                    }
                }
            }
    }
    
    public void drawAroundBlock(Vector3d pos, int color, int my) {
        try {
            
            ready();
            translate(-this.pos.x, -this.pos.y, -this.pos.z);
            color(color);
            depth(false);
            begin(GL11.GL_QUADS);
            
            
            // bottom
            put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
            put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
            put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
            put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
            
            if(renderType == 0) {
                next();
                
                // top
                put(pos.getX() - 0.5, pos.getY() + my + 1.01, pos.getZ() + 0.5);
                put(pos.getX() + 0.5, pos.getY() + my + 1.01, pos.getZ() + 0.5);
                put(pos.getX() + 0.5, pos.getY() + my + 1.01, pos.getZ() - 0.5);
                put(pos.getX() - 0.5, pos.getY() + my + 1.01, pos.getZ() - 0.5);
                
                next();
                
                // z -
                put(pos.getX() - 0.5, pos.getY() + my + 1.01, pos.getZ() - 0.5);
                put(pos.getX() + 0.5, pos.getY() + my + 1.01, pos.getZ() - 0.5);
                put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
                put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
                
                next();
                
                // z +
                put(pos.getX() - 0.5, pos.getY() + my + 1.01, pos.getZ() + 0.5);
                put(pos.getX() + 0.5, pos.getY() + my + 1.01, pos.getZ() + 0.5);
                put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                
                next();
                
                // x -
                put(pos.getX() - 0.5, pos.getY() + my + 1.01, pos.getZ() - 0.5);
                put(pos.getX() - 0.5, pos.getY() + my + 1.01, pos.getZ() + 0.5);
                put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
                
                next();
                
                // y +
                put(pos.getX() + 0.5, pos.getY() + my + 1.01, pos.getZ() - 0.5);
                put(pos.getX() + 0.5, pos.getY() + my + 1.01, pos.getZ() + 0.5);
                put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
            }
            
            end();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
